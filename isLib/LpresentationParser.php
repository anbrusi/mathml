<?php

namespace isLib;

/**
 * Its aim is to transform a presentation mathml source into an ASCII math expresssion, conforming to the syntax of LasciiParser
 * 
 * INPUT: A presentation mathml expression produced by WIRIS, which can be interpreted as conformant to the syntax of LasciiParser.
 *        mathml is passed as a string to the constructor.
 * 
 * OUTPUT: $this->getAsciiOutput() returns a string suitable to be parsed by LasciiParser
 *         $this->getOutput() returns a string with a <pre> formatable tree of the annotated mathml of the input. Used for debugging
 *         $this-> getXmlCode() returns a string with a <pre> formatable mathml input.. Used for debugging * 
 * 
 * ERRORS:  Errors cause a \isLib\isMathException exception. These exceptions are raised by calling \isLib\LmathError::setError
 *          The array info has keys 'input' a string with zhe mathml code
 *          'nodeName' the name of the node cusing an error 
 *          'translation' a <pre> string with the XML tree annotated by a translation to ascii
 *          In case of errors occurring in the XML tree used for debugging, 'translation' is 'none'
 * 
 * @package isLib
 */

class LpresentationParser {

    /**
     * The presentation mathML, to be parsed
     * 
     * @var string
     */
    private string $mathml;

    private \XMLReader $xmlReader;

    /**
     * True if the last $this->xmlReader returned false
     * 
     * @var bool
     */
    private bool $endOfInput = true;

    /**
     * Tree representation of $this->mathml obtained by the debugging function $this->parseXmlCode
     * 
     * @var string
     */
    private string $xmlCode = '';

    /**
     * String with a <pre> formatted tree which is an annotated tree of the original mathml expression used for debugging
     * 
     * @var string|false
     */
    private string|false $output = false;

    /**
     * The ascii expresion generated by parsing the mathml expression in $this->mathml
     * 
     * @var string
     */
    private string $asciiOutput = '';

    function __construct(string $mathml) {
        $this->mathml = $mathml;
    }

    private function initParser():void {
        $this->xmlReader = new \XMLReader();
        if (!$this->xmlReader->XML($this->mathml)) {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER,1, ['input' => $this->mathml, 'nodeName' => 'none', 'translation' => $this->output] ); // Cannot set data for XMLReader
        }
        $this->read();
        if ($this->endOfInput) {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER,2, ['input' => $this->mathml, 'nodeName' => 'none', 'translation' => $this->output] ); // Void input
        }
    }

    private function read():void {
        $this->endOfInput = !$this->xmlReader->read();
    }

    private function endOf(string $name):bool {
        if ($this->endOfInput) {
            return true;
        }
        return $this->xmlReader->nodeType == \XMLReader::END_ELEMENT && $this->xmlReader->name == $name;
    }

    private function indent(string $txt, int $level):string {
        $indent = '';
        while (strlen($indent) < $level) {
            $indent .= ' ';
        }
        return $indent.$txt;
    }

    private function startNode(string $name, int $level):void {
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT && $this->xmlReader->name == $name) {
            $this->output .= $this->indent('&lt;'.$name.'&gt;', $level);
            switch ($name) {
                case 'mo':
                case 'mi':
                    break;
                case 'mrow':
                case 'mfenced':
                case 'mfrac':
                case 'msup':
                    $symbol = '(';
                    $this->asciiOutput .= $symbol;
                    $this->output .= ' ---> '.$symbol;
                    break;
                case 'msqrt':
                    $symbol = 'sqrt(';
                    $this->asciiOutput .= $symbol;
                    $this->output .= ' ---> '.$symbol;
                    break;
                default:
            }
            $this->output .= "\r\n";
            $this->read();
        } else {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER, 4, ['input' => $this->mathml, 'nodeName' => $name, 'translation' => $this->output]); // Start od XML node expected
        }
    }

    private function endNode(string $name, int $level):void {
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::END_ELEMENT && $this->xmlReader->name == $name) {
            $this->output .= $this->indent('&lt;/'.$name.'&gt;', $level);
            switch ($name) {
                case 'mo':
                case 'mi':
                    break;
                case 'mrow':
                case 'mfenced':
                case 'mfrac':
                case 'msup':
                case 'msqrt':
                    $symbol = ')';
                    $this->asciiOutput .= $symbol;
                    $this->output .= ' ---> '.$symbol;
                    break;
                default:
            }
            $this->output .= "\r\n";
            $this->read();
        } else {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER, 5, ['input' => $this->mathml, 'nodeName' => $name, 'translation' => $this->output]);  // End of XML node expected
        }
    }

    private function operatorNode(int $level):void {
        $this->startNode('mo', $level);
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::TEXT) {
            $this->output .= $this->indent($this->xmlReader->value, $level + 1);
            $symbol = $this->xmlReader->value;
            $this->output .= ' ---> '.$symbol;
            // mb_chr(183) is the middle dot character used in mathematics for multiplication
            if (in_array($symbol, ['*', mb_chr(183)])) {
                $symbol = '*';
            } elseif (in_array($symbol, ['<', mb_chr(60)])) {
                $symbol = '<';
            } elseif (in_array($symbol, ['>', mb_chr(62)])) {
                $symbol = '>';
            } elseif (in_array($symbol, ['|', mb_chr(8744)])) {
                $symbol = '|';
            } elseif (in_array($symbol, ['&', mb_chr(8743)])) {
                $symbol = '&';
            } elseif (in_array($symbol, ['!', mb_chr(172)])) {
                $symbol = '!';
            } elseif (in_array($symbol, ['<=', mb_chr(8804)])) {
                $symbol = '<=';
            } elseif (in_array($symbol, ['>=', mb_chr(8805)])) {
                $symbol = '>=';
            }
            $this->asciiOutput .= $symbol;
            $this->output .= "\r\n";
        }
        $this->read();
        $this->endNode('mo', $level);
    }

    private function identifierNode(int $level):void {
        $this->startNode('mi', $level);
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::TEXT) {
            $this->output .= $this->indent($this->xmlReader->value, $level + 1);
            $symbol = $this->xmlReader->value;
            $this->output .= ' ---> '.$symbol;
            if (in_array($symbol, ['*', mb_chr(960)])) {
                $symbol = 'pi';
            }
            $this->asciiOutput .= $symbol;
            $this->output .= "\r\n";
        }
        $this->read();
        $this->endNode('mi', $level);
    }

    private function groupingNode(string $name, int $level):void {
        $this->startNode($name, $level);
        while (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
            $this->xmlNode($level + 1);
        }
        $this->endNode($name, $level);
    }

    private function mfracNode(int $level):void {
        $this->startNode('mfrac', $level);
        // Numerator
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
            $this->xmlNode($level + 1);
        }
        $symbol = ')/(';
        $this->asciiOutput .= $symbol;
        $this->output .= '          ---> '.$symbol;
        $this->output .= "\r\n";
        // Denominator
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
            $this->xmlNode($level + 1);
        }
        $this->endNode('mfrac', $level);
    }

    private function msupNode(int $level):void {
        $this->startNode('msup', $level);
        // Base
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
            $this->xmlNode($level + 1);
        }
        $symbol = ')^(';
        $this->asciiOutput .= $symbol;
        $this->output .= '          ---> '.$symbol;
        $this->output .= "\r\n";
        // Exponent
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
            $this->xmlNode($level + 1);
        }
        $this->endNode('msup', $level);
    }

    private function sqrtNode(int $level):void {
        $this->startNode('msqrt', $level);
        $this->xmlNode($level + 1);
        $this->endNode('msqrt', $level);
    }

    private function xmlNode(int $level):void {
        $nodeName = $this->xmlReader->name;
        switch ($nodeName) {
            case 'mo':
                $this->operatorNode($level);
                break;
            case 'mi':
                $this->identifierNode($level);
                break;
            case 'mrow':
            case 'mstyle':
            case 'mfenced':
                $this->groupingNode($nodeName, $level);
                break;
            case 'mfrac':
                $this->mfracNode($level);
                break;
            case 'msup':
                $this->msupNode($level);
                break;
            case 'sqrt':
                $this->sqrtNode($level);
            default:
                $this->startNode($nodeName, $level);
                while (!$this->endOf($nodeName)) {
                    if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
                        $this->xmlNode($level + 1);
                    } elseif (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::TEXT) {
                        $this->output .= $this->indent($this->xmlReader->value, $level + 1);
                        $symbol = $this->xmlReader->value;
                        $this->output .= ' ---> '.$symbol;
                        $this->asciiOutput .= $symbol;
                        $this->output .= "\r\n";
                        $this->read();
                    } else {
                        \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER,6, ['input' => $this->mathml, 'nodeName' => 'none', 'translation' => $this->output] ); // unexpected input
                    }
                }
                $this->endNode($nodeName, $level);
        }
    }

    private function parse():void {
        $this->output = '';
        $this->asciiOutput = '';
        $this->initParser();
        if (!$this->xmlReader->name == 'math') {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER,3, ['input' => $this->mathml, 'nodeName' => 'none', 'translation' => $this->output] ); // <math> expected
        }
        $this->xmlNode(0);
    }

    public function getOutput():string {
        $this->parse();
        return $this->output;
    }

    public function getAsciiOutput():string {
        $this->parse();
        return $this->asciiOutput;
    }

    /*******************************************************
     * The functions below are needed only for testing
     *******************************************************/

    private function startNodeC(string $name, int $level):void {
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT && $this->xmlReader->name == $name) {
            $this->xmlCode .= $this->indent('&lt;'.$name.'&gt;', $level);
            $this->xmlCode .= "\r\n";
            $this->read();
        } else {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER, 5004, ['input' => $this->mathml, 'nodeName' => $name, 'translation' => 'none']); // Start of XML node expected
        }
    }

    private function endNodeC(string $name, int $level):void {
        if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::END_ELEMENT && $this->xmlReader->name == $name) {
            $this->xmlCode .= $this->indent('&lt;/'.$name.'&gt;', $level);
            $this->xmlCode .= "\r\n";
            $this->read();
        } else {
            \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER, 5, ['input' => $this->mathml, 'nodeName' => $name, 'translation' => 'none']);  // End of XML node expected
        }
    }

    private function xmlNodeC(string $name, int $level):void {
        $this->startNodeC($name, $level);
        while (!$this->endOf($name)) {
            if (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::ELEMENT) {
                $this->xmlNodeC($this->xmlReader->name, $level + 1);
            } elseif (!$this->endOfInput && $this->xmlReader->nodeType == \XMLReader::TEXT) {
                $this->xmlCode .= $this->indent($this->xmlReader->value, $level + 1);
                $this->xmlCode .= "\r\n";
                $this->read();
            } else {
                \isLib\LmathError::setError(\isLib\LmathError::ORI_PRESENTATION_PARSER,6, ['input' => $this->mathml, 'nodeName' => 'none', 'translation' => 'none']); // unexpected input
            }
        }
        $this->endNodeC($name, $level);
    }

    private function parseXmlCode():void {
        $this->initParser();
        $this->xmlNodeC('math', 0);
    }

    public function getXmlCode():string {
        $this->parseXmlCode();
        return $this->xmlCode;
    }
}