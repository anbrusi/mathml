<?php

namespace isLib;

/**
 * Implements an error signalling facility for LasciiLexer, LasciiParser, Levaluator, Llatex, LmathExpression
 * Exceptions must be thrown by calling self::setError.
 * This generates custom \isLib\isMathException exceptions which are \Exception exceptions augmented by a property 'info'.
 * The default english message is generated by adding the parameters 'origin' and 'number', which yield 'code'.
 * Translations can be made by translating self::errors. The entry can be obtained from 'code', the english 'message' can be discarded
 * 
 * The whole information available to debug an error is contained in the exception
 * 
 * The possible keys in 'info' are 'origin' dependent.
 * 
 * For LEXER Errors the keys are:
 *     'input' the original expression split in tokns by the lexer, 
 *     'ln' the line of the error numbered from 1
 *     'cl' the column of the error numbered from 0
 * 
 * 
 * @package isLib
 * @author A. Brunnschweiler
 * @version 11.09.2024
 */
class LmathError {
    public const ORI_LEXER = 1000;
    public const ORI_PARSER = 2000;
    public const ORI_EVALUATOR = 3000;
    public const ORI_LATEX = 4000;
    public const ORI_PRESENTATION_PARSER = 5000;
    public const ORI_MATH_EXPRESSION = 6000;
    public const ORI_FILTER = 7000;
    public const ORI_MATH_TRANSFORMAUION = 8000;
    public const ORI_NC_INTERPRETER = 9000;
    public const ORI_NC_RATIONALNUMBERS = 10000;
    public const ORI_NC_RATPOLYNOMIALS = 11000;
    public const ORI_NC_NATURALNUMBERS = 12000;
    public const ORI_TREE_TRANSFORMS = 1300;

    public const errors = [
        // Lexer errors
        1001 => 'Initialization failed, possibly the expression is empty',
        1002 => 'Digit expected after "." in decimal part of number',
        1003 => 'Digit expected after "E" in scale part of number',
        // Parser errors
        2001 => 'Unexpected end of input in boolatom',
        2002 => 'boolatom or "!" expected',
        2003 => 'Left term in “|“ must be bool',
        2004 => 'Right term in “|“ must be bool',
        2005 => 'Left term in “&“ must be bool',
        2006 => 'Right term in “&“ must be bool',
        2007 => ') expected',
        2008 => 'Negation must be followed by a boolean',
        2009 => 'Left part of comparison must be float',
        2010 => 'Right part of comparison must be float',
        2011 => 'Unary minus can be applied only to float value',
        2012 => 'Left part of addop must be of float type',
        2013 => 'Right part of addop must be of float type',
        2014 => 'Left part of mulop must be of float type',
        2015 => 'Right part of mulop must be of float type',
        2016 => 'Base in power must be float',
        2017 => 'Exponent in power must be float',
        2018 => 'Unexpected end of input in expression',
        2019 => 'Atom or (boolexpression) expected',
        2020 => '( expected',
        2021 => ', expected',
        2022 => 'unimplemented number of arguments',
        2023 => 'mathconst, variable or function not in symbol table',
        2024 => 'Atom expected',
        2025 => 'Cannot get variable names. There is no parse tree',
        2026 => '] expected',
        // Evaluator errors
        3001 => 'Unimplemented node type in evaluation',
        3002 => 'Division by zero',
        3003 => 'Unimplemante matop',
        3004 => 'Variable cannot be evaluated to a float',
        3005 => 'Variable is missing in variable list',
        3006 => 'Unimplemented function',
        3007 => 'Left part of comparison is not numeric',
        3008 => 'Right part of comparison is not numeric',
        3009 => 'Left part of boolean operator is not bool',
        3010 => 'Right part of boolean operator is not bool',
        3011 => 'Unknown comparison symbol',
        3012 => 'Unknown boolop',
        3013 => 'Node is not of type boolean',
        // Latex errors
        4001 => 'Unknown operator precedence',
        4002 => 'unimplemented node type',
        4003 => 'Invalid number format',
        4004 => 'Unhandled node type',
        // Presentation parser errors
        5001 => 'Cannot set data for XMLReader',
        5002 => 'First read in XMLReader failed',
        5003 => '&lt;math&gt; expcted',
        5004 => 'Start of XML node expected',
        5005 => 'End of XML node expected',
        5006 => 'Unexpected input',
        // MathExpression errors
        6001 => 'Void expression',
        6002 => 'Unknown error origin',
        // Filter errors
        7001 => 'ASCII content missing',
        // MathTransformation errors
        8001 => 'Problem must contain exactly one mathematical formula',
        // Nano CAS interpreter
        9001 => 'Empty command',
        9002 => 'Command expected',
        9003 => 'Open parenthesis expected',
        9004 => 'Close parenthesis expected',
        9005 => 'Literal expected',
        9006 => 'Comma expected',
        9007 => 'Unknown command',
        9008 => 'Minuend smaller than subtrahend',
        9009 => 'Zero divisor',
        9010 => 'No divisors of zero',
        9011 => 'Unexpected end of input',
        9012 => 'Variable not found',
        9013 => 'Wrong nanoCAS type',
        9014 => 'Slash expected',
        9015 => 'xponent limited to radix',
        9016 => 'Alphas expected',
        9017 => 'Digits expected',
        9018 => 'CAS Natural number expected',
        9019 => 'CAS integer expected',
        9020 => 'CAS rational number expected',
        // Nano CAS rational numbers
        10001 => 'No negative power of zero',
        // Nano CAS rational polynomials
        11001 => 'Monomial expected in multiplication',
        // Nano CAS natural numbers
        12001 => 'No machine division by zero',
        // Tree traansforms
        13001 => 'Summand array below 2',
    ];

    public static function setError(int $origin, int $number, array $info = [], ?\Throwable $previous = null) {
        switch ($origin) {
            case self::ORI_PRESENTATION_PARSER:
                $oriName = 'PRESENTATION PARSER: ';
                break;
            case self::ORI_LEXER:
                $oriName = 'LEXER: ';
                break;
            case self::ORI_PARSER:
                $oriName = 'PARSER: ';
                break;
            case self::ORI_EVALUATOR:
                $oriName = 'EVALUATOR: ';
                break;
            case self::ORI_LATEX:
                $oriName = 'LATEX: ';
                break;
            case self::ORI_MATH_EXPRESSION:
                $oriName = 'MATH EXPRESSION: ';
                break;
            case self::ORI_FILTER:
                $oriName = 'FILTER: ';
                break;
            case self::ORI_MATH_TRANSFORMAUION:
                $oriName = 'MATH TRANSFORMATION: ';
                break;
            case self::ORI_NC_INTERPRETER:
                $oriName = 'NC_INTERPRETER: ';
                break;
            case self::ORI_NC_RATPOLYNOMIALS:
                $oriName = 'NC_RATPOLYNOMIALS: ';
                break;
            case self::ORI_NC_NATURALNUMBERS:
                $oriName = 'NC_NATURALNUMBERS: ';
                break;
            case self::ORI_TREE_TRANSFORMS:
                $oriName = 'TREE_TRANSFORMS: ';
                break;
            default:
                $oriName = 'UNKNOWN: ';
        }
        $code = $origin + $number;
        $message = $oriName.self::errors[$code];
        throw new isMathException($message, $code, $info, $previous);
    }
}

class isMathException extends \Exception {

     /**
     * Array containing additional information about the exception
     * Possible Keys are:
     *  'ln' the line of the error, 
     *  'cl' the column of the error,
     *  'errtxt' a text pinning down the error
     * 
     * @var array
     */
    public array $info = [];

    public function __construct($message, $code, $info = [], \Throwable $previous = null) {
        $this->info = $info;
        parent::__construct($message, $code, $previous);
    }

}